#ifndef __MACRO_DEF__
#define __MACRO_DEF__


#define PRINT_INSIDE 0
#define PRINT_OUTSIDE 0
#define PRINT_STEPS 0
#define PRINT_EXPECTATION_COUNT 0
#define PRINT_GRAMMAR_EACH_UPDATION_BEFORE 0
#define PRINT_GRAMMAR_EACH_UPDATION_AFTER 0
#define DEBUG_MODE 0
#define SANITARY_OUTPUT 1

#if SANITARY_OUTPUT == 1
#undef PRINT_INSIDE
#undef PRINT_OUTSIDE
#undef PRINT_STEPS
#undef PRINT_GRAMMAR_EACH_UPDATION_BEFORE
#undef PRINT_GRAMMAR_EACH_UPDATION_AFTER
#undef PRINT_EXPECTATION_COUNT
#endif


// Handle cuTENSOR errors
#define HANDLE_ERROR(x)                                             \
{ const auto err = x;                                               \
    if( err != CUTENSOR_STATUS_SUCCESS )                              \
    { printf("Error: %s\n", cutensorGetErrorString(err)); exit(-1); } \
};

#define HANDLE_CUDA_ERROR(x)                                      \
{ const auto err = x;                                             \
    if( err != cudaSuccess )                                        \
    { printf("Error: %s\n", cudaGetErrorString(err)); exit(-1); } \
};


#define BYTES_GRAMMAR_TABLE_ITEMS 12
#define BYTE_4_CELL_PER_GRAMMAR_TABLE_ITEMS 3

#define MAX_SEQUENCE_LENGTH 500
#define _32bit_t int32_t
#define SYMBOL_ID(SYMBOL_DESC) 
#define IS_EPSILON(SYMBOL_ID) ((SYMBOL_ID) == 0xFFFF)
#define IS_TERMINATE(SYMBOL_ID) ((SYMBOL_ID) >= N && (SYMBOL_ID) != 0xFFFF)
#define IS_NONTERMINATE(SYMBOL_ID) ((SYMBOL_ID) < N)

#define ALPHA_INCREASE(SYMBOL, I, J, VALUE) alpha[(SYMBOL) * MS * MS + (I) * MS + J] +=  VALUE;
#define BETA_INCREASE(SYMBOL, I, J, VALUE) beta[(SYMBOL) * MS * MS + (I) * MS + J] +=  VALUE;
#define MU_INCREASE(SYMBOL, I, J, VALUE) mu[(SYMBOL) * MS * MS + (I) * MS + J] +=  VALUE;

#ifdef COMPUTING_IN_LOG_SPACE
#define ALPHA_INCREASE_LOG_SPACE(SYMBOL, I, J, VALUE) alpha[(SYMBOL) * MS * MS + (I) * MS + J] =  log_sum_exp(alpha[(SYMBOL) * MS * MS + (I) * MS + J], VALUE);
#define BETA_INCREASE_LOG_SPACE(SYMBOL, I, J, VALUE) beta[(SYMBOL) * MS * MS + (I) * MS + J] =  log_sum_exp(beta[(SYMBOL) * MS * MS + (I) * MS + J], VALUE);
#define MU_INCREASE_LOG_SPACE(SYMBOL, I, J, VALUE) mu[(SYMBOL) * MS * MS + (I) * MS + J] =  log_sum_exp(mu[(SYMBOL) * MS * MS + (I) * MS + J], VALUE);
#endif

#define ALPHA(SYMBOL, I, J) alpha[(SYMBOL) * MS * MS + (I) * MS + J] 
#define BETA(SYMBOL, I, J) beta[(SYMBOL) * MS * MS + (I) * MS + J]
#define MU(GID, I, J) mu[(GID) * MS * MS + (I) * MS + J]
#define ALPHA_GET(SYMBOL, I, J) ((I) > (J) ? 1.0f : (SYMBOL) < N ? ALPHA(SYMBOL, I, J) : ((SYMBOL) == 0xFFFF ? 0.0f : ((I) == (J) && sequence[I] == (SYMBOL) ? 1.0f : 0.0f)))

#define SYMBOL_STR(SYMBOL_ID) ((SYMBOL_ID) < N ? grammar->reversed_nonterminate_map[(SYMBOL_ID)]: grammar->reversed_terminate_map[(SYMBOL_ID) - N])

#endif
